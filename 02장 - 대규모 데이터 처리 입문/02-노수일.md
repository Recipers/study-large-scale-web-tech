# 2. 대규모 데이터 처리 입문
- 대규모 데이터 특유의 환경 알기
    - 대규모 데이터란 무엇인가
    - 대규모 데이터란 어느정도인가
    - 소량의 데이터 처리랑 무엇이 다른가
## 2-4. 하테나 북마크의 데이터 규모
- 데이터가 많을수록 처리에 시간이 걸린다
### 하테나 북마크를 예로 본 대규모 데이터
- 하테나 예시
    - select count(*) from relword; -> 3억 5천만
### 하테나 북마크의 데이터 규모
- 레코드 건수 : 1,500만, 5,000만
- entry 테이블 : 3GB
- bookmark 테이블 : 5.5GB
    - 간단히 말해서 기가바이트 단위가 된다고 할 수 있음
    - Google, Yahoo -> 초 대규모라고 할 수 있음   
### 대규모 데이터로의 쿼리
- 하테나 정도의 규모정도 되면 DB 쿼리 결과가 나올 때의 느낌도 달라짐
- 인덱스가 없을 때 200초가 넘어도 결과가 나오지 않음
- 레코드 수가 수천만, 수GB 에서 수백 GB가 되면, 아무 생각없이 던진 쿼리에 대해 응답하지 않음
- 데이터가 많으면 처리하는데 시간이 걸리게 됨
## 2-5 대규모 데이터 처리의 어려운점
- 메모리와 디스크
### 대규모 데이터는 어떤 점이 어려운가?
- 메모리 내에서 계산할 수 없다.
    - 메모리에 올리지 않으면 기본적으로 디스크를 읽어가면서 검색하게 되어 좀처럼 발견할 수 없는 상태가 됨
    - 계산량이 많아지는 것 보다 디스크를 읽고 있다는 점이 문제가 됨
    - 어떻게 대처할 것인가..
### 메모리와 디스크의 속도차
- 메모리는 10⁵ ~ 10⁶ 배 이상 고속
### 디스크는 왜 늦을까?
- 메모리
    - 전기적인 부품이므로 물리적 구조는 탐색 속도와 그다지 관계 없음
    - 포인터가 마이크로초 단위로 이동 가능
- 디스크
    - 동축 상에 원반이 쌓여 회전하고 여기서 데이터를 읽음
    - 물리적인 구조가 탐색 속도에 영향을 줌
#### 탐색속도에 영향을 주는 다양한 요인
- 디스크의 데이터가 여기저기 뿔뿔이 흩어져 있는 경우
- 메모리는 물리적인 동작이 없음
- 탐색에 사용되는 것이 CPU 캐시에 올리기 쉬운 알고리즘이나 데이터 구조라면 나노초 단위로 초리 가능
### Linux 단일 호스트의 부하
- 부하분산
    - 복수의 호스트로 처리를 나누어 담당시키는 것
    - 한대에서 처리할 수 있는 부하를 10대로 분산하는 것은 본말이 전도된 것
    - **단일 서버의 성능을 충분히 끌어낼 수 있는 것을 시작**으로 복수 서버에서의 부하분산이 의미를 가짐
#### 추측하지 말라, 계측하라
- 단일 호스트의 성능을 끌어내는 데에는 서버 리소스의 이용현황을 정확하게 파악할 필요가 있음
- 계측작업이 가장 중요함
- 시스템의 병목을 규명하고, 이를 집중적으로 제거해야 성능을 올릴 수 있음
#### 병목 규명작업의 기본적인 흐름
- Load Average 확인
- CPU, I/O 중 병목 원인 조사
#### Load Average 확인
- 시스템 전체의 부하상황을 나타내는 지표
- top, uptime 등의 명령으로 Load Average 확인 가능
- Load Average만으로 병목의 원인이 어딘지 판단 불가능, 이 값을 시초로 병목지점 조사
- Load Average가 낮은데 시스템 전송량이 낮은 경우
    - 소프트웨어 설정이나 오류, 네트워크, 원격 호스트측 원인 확인
#### CPU, I/O 중 병목 원인 조사
- sar, vmstat으로 CPU 사용률이나, I/O 대기율의 추이 확인 가능
- CPU 부하가 높은 경우의 조사 순서
    - 사용자 프로그램의 처리가 병목인지, 시스템 프로그램이 원인인지 확인
    - ps로 볼 수 있는 프로세스의 상태나 CPU 사용시간 등을 보면서 원인이 되고 있는 프로세스를 찾아봄
    - strace, oprofile로 프로파일링 해서 병목지점을 좁힐 것
- CPU 부하가 걸리고 있는 상황
    - 디스크나 메모리 용량 등 그 밖의 부분에서는 병목이 되지 않는 이상적인 상태
        - 서버 증설
        - 프로그램 로직, 알고리즘 개선
    - 프로그램이 폭주
        - 오류 개선
- I/O 부하가 높은 경우
    - 입출력이 많은 경우
    - 스왑이 발생해서 디스크 액세스가 발생하고 있는 경우
- I/O 부하 조사
    - 특정 프로세스가 극단적으로 메모리를 소비하고 있는지 확인
    - 프로그램의 오류 확인
    - 탑재된 메모리가 부족한 경우, 증설 or 분산 검토
- 스왑이 발생하지 않고 디스크로의 입출력이 빈번하게 발생하고 있는 상황
    - 캐시에 필요한 메모리가 부족한 경우
    - 메모리 증설로 캐시영역 확대
    - 데이터 분산이나 캐시서버 도입 검토
### OS 튜닝이란 부하의 원인을 알고 이것을 제거하는 것
- 튜닝의 본래 의미는 **병목이 발견되면 이를 제거하는 작업**
- 하드웨어, 소프트웨어가 지니고 있는 성능 이상의 성능을 내는 것은 불가능
- I/O 성능을 개선하기 위해 규명할 것
    - 메모리를 증설해서 캐시 영역을 확보함으로써 대응 가능한가
    - 원래 데이터량이 너무 많지는 않은가
    - 애플리케이션 측의 I/O 알고리즘을 변경할 필요가 있는가
## 2-6. 규모조정의 요소
### 규모조정, 확장성
- 대규모 환경
    - 서버를 여러 대 나열해놓고 그 서버로 부하를 분산
    - 규모조정(scaling), 확장성(scalability)
- scale-up
    - 고가의 빠른 하드웨어를 사서 성능을 높이는 전략
- scale-out
    - 저가의 일반적인 하드웨어를 많이 나열
    - 웹 서비스에 적합한 형태
         - 비용이 저렴
         - 시스템 구성에 유연성이 있음 (최소한의 투자 가능)
### 규모조정의 요소
- scale-out은 CPU 부하의 확장성을 확보하기 쉬움
- HTTP 요청-응답 구조에서 기본적으로 CPU 부하만 소요됨 (프록시, AP 서버)
- DB 서버 측면에서는 I/O 부하가 걸림
### 웹 애플리케이션과 부하의 관계
- AP 서버는 CPU 부하만 걸리므로 분산이 간단함
    - 대수를 늘리기만 하면 간단히 확장 가능
    - 복사본을 마련해놓고 로드밸런서로 요청을 균등하게 분산
- 쓰기는 간단히 분산할 수 없다 (DB)
### DB 확장성 확보의 어려움
- 디스크가 느리다는 문제도 여기에 영향을 미침
- DB는 디스크를 많이 사용하므로 디스크 I/O 발생이 많은 구성
- 대규모 환경에서는 I/O 부하를 부담하고 있는 서버는 분산시키기 어려움

### 두 종류의 부하와 웹 애플리케이션
- AP 서버는 DB로부터 얻은 데이터를 가공해서 클라이언트로 전달하는 처리
    - CPU 바운드한 서버
- DB 서버는 데이터를 디스크로부터 검색하는 것이 주된 일
    - 대규모 데이터가 될 수록 I/O 영향이 커지는 I/O 바운드한 서버
#### 멀티태스킹 OS와 부하
- 매우 짧은 시간간격으로 여러 태스크를 전환해가면서 처리
- 실행할 테스크가 늘어나면 대기상태가 늘어나고 프로그램의 실행지연으로 나타남
- Load Average가 높은 상황은 지연이 되는 부하가 높은 상황임
#### Average가 보고하는 부하의 정체
- 하드웨어는 일정 주기로 CPU로 인터럽트라는 신호를 보냄
- 타이머 인터럽트마다 Load Average 값이 계산됨
- 커널은 다이머 인터럽트가 발생했을 때 실행가능한 상태인 태스크와 I/O 대기인 태스크의 갯수를 세어둠
- 이 값을 단위시간으로 나눈 값이 Load Average
- 실행가능 상태라는 것은 다른 태스크가 CPU를 점유하고 있어 계산을 시작할 수 없는 태스크
- Load Average가 의미하는 부하
    - 처리를 실행하려고 해도 실행할 수 없어서 대기하고 있는 프로세스의 수
    - CPU의 실행권한이 부여되기를 기다리고 있는 프로세스
    - 디스크 I/O가 완료하기를 기다리고 있는 프로세스
## 2-7. 대규모 데이터를 다루기 위한 기초지식
### 프로그래머를 위한 대규모 데이터 기초
- 프로그램을 작성할 때의 요령
- 프로그램 개발의 근간이 되는 기초라는 점에서 알아두었으면 하는 것
### 대규모 데이터를 다루는 세 가지 급소
- 어떻게 하면 메모리에서 처리를 마칠 수 있을까
    - 디스크 seek 횟수가 확장성, 성능에 크게 영향을 주기 때문
- 데이터량 증가에 강한 알고리즘 사용
    - 선형탐색 vs Log Order
- 데이터 압축이나 검색기술 활용
    - 데이터량을 줄일 수 있으면 디스크 읽는 횟수를 최소화 할 수 있음
    - 메모리에 캐싱하기도 쉬워짐
    - 검색엔진이 있는 경우, DB 서버말고 해당 검색엔진을 이용하면 됨
### 대규모 데이터를 다루기 전 3대 전제지식
- OS 캐시
- 분산을 고려해서 RDBMS를 운영할 때는 어떻게 해야 하는가
- 대규모 환경에서의 알고리즘과 데이터 구조
### Load Average 다음은 CPU 사용률과 I/O 대기율
#### sar로 CPU 사용률, I/O 대기율 확인
- %user, %system CPU 사용률 확인
- %iowait 값으로 I/O 대기율 확인 
### 멀티 CPU와 CPU 사용률
- 멀티코어가 되면, CPU가 물리적으로 하나이더라도 OS에서는 여러 CPU가 탑재되어 있는 것처럼 보임
- CPU 사용률도 각각의 CPU별로 유지
