# 4. 분산을 고려한 MySQL 운용
### 분산된 시스템 알기
- 국소성을 고려하고, 메모리를 조정하고, 메모리 증설로도 대응할 수 없을 경우 분산
- DB 스케일 아웃 전략 (MySQL)
## 4-11. 인덱스를 올바르게 운용하기
- 분산을 고려한 MySQL 운용의 대전제
### 분산을 고려한 MySQL 운용, 세 가지 포인트
- OS 캐시 활용
- 인덱스
- 확장을 전제로 시스템을 설계해둔다
### OS 캐시 활용
- 전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 한 적어지도록 유지
- 부족할 경우 메모리 증설
- ex) 3억 레코드정도의 데이터가 있으면, 1레코드에 8바이트 칼럼을 추가하면 8*3억 (3GB)
- 스키마를 조금 변경하는 것만으로 기가비이트 단위로 데이터가 증감
- 대량의 데이터를 저장하려는 테이블은 레코드가 가능한 한 작아지도록 컴팩트하게 설계할 것
#### 정규화
- 정규화해서 DB를 나누어놓아도 괜찮은 것인가?
    - 결론은 좋다 (특정 컬럼은 존재할 시에만 사용가능함)
    - 그러나 쿼리가 복잡해져 수행 속도가 떨어지는 것도 생각해야됨 (trade-off)
### 인덱스의 중요성
- 알고리즘, 데이터 구조에서 탐색을 할 때는 기본적으로 트리가 널리 사용됨
- MySQL의 인덱스는 기본적으로 B+트리
- B 트리
    - 트리를 구성하는 각 노드가 여러 개의 자식을 가질 수 있는 다분 트리
    - 삽입 삭제를 반복한 경우에도 트리의 형태에 치우침이 생기지 않는 평형 트리
    - 검색을 할 때에 트리 높이만큼의 횟수만 자식을 찾아가면 됨
    - 데이터 건수 n에 대해 반드시 log n 이되므로 O(log n)
#### 이분트리와 B트리 비교해보기
- B트리는 각 노드를 1블록에 모아서 저장되도록 구성할 수 있으므로 디스크 Seek 발생횟수를 최소화 할 수 있음
- 이분트리는 특정 노드를 모아서 1블록에 저장하는 등의 작업이 어려움
#### MySQL에서 인덱스 만들기
- MySQL에서 인덱스를 만들면 B+트리에 의한 트리 데이터 구조가 생김
### 인덱스의 효과
- ex) 4,000만건
    - 선형 탐색 : O(n) -> 4,000
    - B트리 : O(log n) -> 25.25
- 계산량 개선, 디스크 구조에 최적화 (Seek 횟수) 개선
#### 인덱스의 작용
- MySQL 특징
    - 인덱스를 걸어놓고 있는 칼럼을 대상으로 한 쿼리라도 던지는 SQL에 따라서 사용되거나 사용되지 않기도 함
- 인덱스가 사용되는 것
    - where, order by, group by  조건에 지정된 칼럼
- 인덱스로 작용하는 것
    - 명시적으로 추가한 인덱스
    - Primary Key, UNIQUE 제약
- 복수 칼럼에 동시에 인덱스를 태우고자 할 경우는 복합 인덱스를 사용해야 한다
    - 한 번의 쿼리에서 하나의 인덱스만 사용
### 인덱스가 작용하는지 확인하는 법
- explain
#### explain 명령에서 속도에 유의하라
- SQL 수반하는 프로그램 개발 시 explain 명령으로 인덱스가 작용하는지 확인하면서 개발하면 좋음
- Extra 열도 중요
- Using where, Using filesort, Using temporary
- Using filesort, Using temporary 나오는 것은 그다지 틀이 좋은 쿼리는 아님
#### 인덱스의 간과
- 서비스를 운용하다 보면 인덱스가 작용하지 않는 쿼리를 알게 모르게 사용하게 되는 경우도 있음
- 감시방안을 늘림으로써 사후 대응하는 것이 의외로 유효한 방법
    - slow-log 리포트
    - 발견 후 대응이 유효한 경우가 많음
## 4-12. MySQL의 분산
- 확장을 전제로 한 시스템 설계
### MySQL의 레플리케이션 기능
- 레플리케이션
    - 마스터를 정하고 마스터를 뒤따르는 슬레이브를 정함
    - 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신
- select 등 참조 쿼리는 슬레이브, 갱신 쿼리는 마스터로
- MySQL Proxy
### 마스터/슬레이브의 특징
- 참조계열은 확장하고 갱신계열은 확장하지 않는다
- 마스터는 확장할 수 없다 (할 순 있지만 험난함)
- 웹 애플리케이션의 90% 이상은 참조 계열 쿼리임, 쓰기는 상대적으로 훨씬 적음
#### 갱신/쓰기 계열을 확장하고자 할 때
- 테이블을 분할해서 테이블 크기를 작게 해줌
- 테이블 파일이 분산되면 동일 호스트 내에서 여러 디스크를 가지고 분산할 수 있음
- 다른 서버로 분산 가능
- 처음부터 RDBMS를 쓰지 않는 방법도 고려
    - key-value 스토어
    - 오버헤드가 적고 압도적으로 빠르며 확장하기 쉬움
## 4-13. MySQL의 스케일아웃과 파티셔닝
### MySQL의 스케일 아웃 전략
- 메모리 증설이 불가능 하면 파티셔닝
### 파티셔닝(테이블 분할)에 관한 보충
- 테이블 A와 테이블 B를 서로 다른 서버에 놓아서 분산
### 파티셔닝을 전제로 한 설계
- 서로 다른 서버에 있는 테이블을 JOIN하는 기능이 기본적으로 없음
- JOIN 쿼리 대상이 되는 테이블을 분할하지 않을 것이라고 보장할 수 있을 때만 사용
### JOIN 배제
- join 후 in (결과) 로 분리하는 방식 ??
### 파티셔닝의 상반관계
- 좋은 점
    - 부하가 내려감
    - 국소성이 늘어나서 캐시효과가 높아짐
- 나쁜 점
    - 운용이 복잠해짐
        - 어떤 서버가 어떤 일을 하는지 파악해둬야 함 (장애 대응)
    - 고장률이 높아짐
#### 다중화에 필요한 서버 대수는
- DB 서버 master/slave 구조에서 기본적으로 4대 1세트가 기본
    - slave 중 한대가 고장나면, 한대는 데이터 복사를 해야하는데 3대를 운용하게 될 경우 slave 서비스 정지가 발생함
#### 애플리케이션의 용도와 서버 대수
- 무정지가 필수 조건인지 여부는 어플리케이션 용도에 따라 다름
- 따라서, 반드시 4대가 필요한다고 할 순 없음
#### 서버 대수와 고장률
- 분할하면 대수가 한꺼번에 늘어남
- 고장 확률도 올라감
