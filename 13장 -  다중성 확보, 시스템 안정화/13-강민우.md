# 13장 - 다중성 확보, 시스템 안정화
## 다중화와 가동률 - 시스템을 얼마나 멈추지 않도록 할 것인가
- 흔히 24시간 365일 서버가 꺼지지 않으면 100% 가동률이라고 함
- 하테나는 실제 100% 반드시 달성할 수 있는 시스템으로는 구성하지 않음
	- Q. 100%를 구성하려고 하면 100%를 달성할 수 있는건가..?
- 가동률을 높이기 위해서 가장 중요한 부분으로 SPOF를 제거해야 됨

- - -
## 강의33: 다중성 확보
### 다중성 확보 - AP 서버
- 다중화는 확장성에서 생각했던 방식대로 **AP 서버를 여러 대 늘어놓는 것**이 기본
	- 이때 서버의 일부가 정지하더라도 충분히 처리할 수 있는 처리능력을 확보해야 함
- 서버가 고장날 경우를 대비해 로드밸런서는 `failover`, `failback`를 준비한다.
	- `failover`: 고장 난 서버를 자동으로 **분리**
	- `failback`: 서버가 복구되면 원 상태로 **복귀**
	- 이를 위해 로드밸런서는 AP, DB 서버들에 대해 주기적으로 헬스체크를 하고 있다.

### 다중성 확보 - DB 서버
- AP 서버와 같이 서버를 여러 대 나열해 일부가 고장나도 충분한 처리능력을 갖을 수 있도록 만들자
- 하테나는 `멀티 마스터`로 마스터를 다중화하고 있음
	- 멀티 마스터 : 쌍방으로 레플리케이션 하는 방식이다.
	- 서로가 서로의 슬레이브가 되는 상태. 한쪽에 쓰기 작업을 하면 반대쪽으로 전달
- MySQL은 실제 한 쪽에 쓰기 작업을 하면 **반대쪽으로 전달되는 흐름이기 때문에 약간의 지연 발생**
	- 즉, 밀리초 단위로 보면 **`데이터가 일치하지 않는 상태가 항상 존재`**
	- AP 서버에서 볼 때 쓰기 작업을 위한 기능(메서드)을 수행했더라도 실제 DB의 반영되지 않은 등의 모순이 발생할 수 있음
- 엔터프라이즈는 이 부분에 대한 대첵으로 레플리케이션을 동기적으로 처리
	- 이에 따라 슬레이브까지 쓰여졌다는 것을 확인하면 클라이언트에 결과를 반환하도록 할 수 있음
	- 동기는 확실하게 보장할 수 있지만 성능이 엄청 안 좋아짐
	- 웹 서비스에서는 동기가 맞지 않는 리스크에 대해 어느 정도 받아들여 성능을 높이는 것이 좋아보임

#### 멀티 마스터
- 페일 오버의 동작 방식은 상호간에 `VRRP(Virtual Router Redendancy Protocol)`이라는 프로토콜로 감시하고 있음
- VRRP에 의해 안쪽이 분리된 것을 알게 되면 자신이 Active 마스터로 승격함

<img src="../image/Pasted image 20250421164827.png" width="700" height="400">
- 멀티 마스터 구성에서 서버는 기본적으로 2대 구성, (Active/Standby 로)
	- `Active/Standby`는 기본적으로 Active만 쓰기 작업 진행
	- Active가 죽으면 Standby가 Active로 승격

> **다중성 확보(DB 서버)**
> - 슬레이브
> 	- 서버를 여러 대 나눔 (일부가 중지하더라도 충분히 동작할 수 있도록 구성)
> - 마스터
> 	- 멀티 마스터
> 	- 상호간 레플리케이션
> 	- 전환 타이밍에 따라 동기가 많지 않을 위험이 남아있음

### 다중성 확보 - 스토리지 서버
- 하테나에서 이미지와 같은 미디어 파일을 저장하기 위한 분산 스토리지 서버로 `MogileFS` 사용
	- `MogileFS` : 미국 Six Apart에서 개발된 분산 파일시스템 (Perl로 구현)
- 분산 파일 시스템을 사용함으로써 대량의 파일을 보존할 수 있는 확장성과 일부 서버가 다운되더라도 전체 장애가 되지 않도록 다중성 확보 가능
- 분산 파일시스템에 이미지 등의 미디어 파일을 저장하고 있음 (닌텐도용 DSi, PC용 Flash, JPEG 등)

- - -
## 강의 34: 시스템 안정화
### 시스템 안정화를 위한 상반관계
- `안정성`과 `자원효율` 간의 상반관계
	- 메모리를 튜닝해 8GB 중 7.5GB 까지 메모리를 사용하고 있다면, 처리해야 할 데이터량이 늘어나거나 애플리케이션에 버그로 인해 메모리 누수가 발상한다면 바로 **서비스 장애**로 이어진다.
- `안정성`과 `속도`에 대하여 상반관계
	- CPU를 거의 한계에 다다를 정도로 사용한다면 서버 대수를 줄일 수 있어 비용 측면에서 유리하지만, 1대에 장애가 발생해 전체 처리 능력이 부족해져 요청을 다 처리하지 못해 장애가 발생할 수 있음
- `안전성`을 위해 이를 위해 `메모리와 CPU는 7할 까지` 사용하는 등 여유를 가질 수 있는 설계가 중요
	- 서버의 일부가 다운되더라도 문제가 없더록 한계까지 사용하지 않고 어느 정도 버퍼를 유지하고, 버퍼가 부족해지면 서버를 추가할 수 있도록 구성하자.

### 시스템의 불안정 요인
> **전형적인 불안정 요인들**
> - 애플리케이션/서비스 레벨 -> 부하 증가
> 1. 기능 추가
> 2. 메모리 누수
> 3. 지뢰
> 4. 사용자의 액세스 패턴
> 5. 데이터량 증가
> 6. 외부연계 추가
> 
> - 하드웨어 -> 처리능력 저하
> 7. 메모리, 하드디스크 장애
> 8. NIC(Network Interface Card) 장애

#### 1. 기능 추가 & 2. 메모리 누수
- 애플리케이션, 서비스 레벨에서 기능 추가 -> 시스템의 불안정 요인, 해당 기능이 예상보다 무거워 부하가 증가돼 장애 발생
- Perl과 같이 Lightweight 언어를 사용하다보면 메모리 누수를 완전히 배제하기 어려움

#### 3. 지뢰
- 특정 URL이 읽히면(지뢰를 밟으면) 무한한 응답을 기다려야 되는 경우
	- 원인으로 메모리 누수나 무한루프 등 다양한 요인이 있음
- 지뢰를 방어하기 위해 가볍게 구현하거나 도메인 적으로 제한하는 방법이 있음
	- ex) 최초 출력하는 코멘트 개수를 1000건으로 제한하는 방식

#### 4. 사용자의 엑세스 패턴
- Slashdot 또는 Digg 효과라고 하기도 함
- 인기가 많은 사이트에 링크를 걸어 해당 사이트 사용자가 집중적으로 접속해 다운되는 경우
- 이럴 경우를 대비하는 방식으로는 캐시 서버를 사이에 추가하는 방식이 있음
	- 게스트 사용자의 경우 캐시를 반환하도록. (2001년 9월 미국의 Yahoo가 터졌을 때 컨텐트를 캐싱해 장애 복구)

#### 5. 데이터량 증가
- 시간이 지날수록 데이터량은 증가한다. 이것이 전체적인 부하의 증가로 이어져 시스템이 불안정해질 수 있음
- 역정규화로 데이터량 증가에 대해 해결할 수 있음
	- ex) 별 1000개를 달면 1000개의 레코드를 추가 -> 1000개를 추가했다는 정보를 가진 레코드 1개만 추가 

#### 6. 외부연계 추가
- 웹 API나 Amazon 웹 API 등 새롭게 추가되는 등 새로운 웹 API를 연결할 때 불안정한 요인이 됨
	- ex) 하테나에서 일부 Amazon을 사용할 때 Amazon이 다운되면 하테나도 같이 다운되는 상황
- 외부 시스템이 다운되거나 부하가 높을 때 연계하고 잇는 서비스가 영향을 받지 않도록 구성하자.
	- `해당 하는 부분만 작동을 안하고 다른 부분은 출력하는 방법` 등등

#### 7. 메모리, 하드 디스크 & 9. NIC 장애
- 하드웨어 자체적으로 장애가 발생하는 경우 - 현재 나의 프로젝트는 거의 클라우드를 사용하므로 생략

- - -
## 강의35: 시스템 안정화 대책
### 실제 안정화 대책
- 안정화 대책의 방식으로 `적절한 버퍼 유지`와 `불안정 요인 제거` 두 가지가 있음
	- 적절한 버퍼 유지: 한계의 7할 까지 운영하기 이를 넘어가면 서버를 추가하고나 메모리 증설
	- 불안정 요인 제거: `SQL 부하대첵`, `메모리 누수 줄이기`, `비정상 동작 시 자율제어`, 테스트? 등
		- `SQL 부하가 심할 것`으로 예상되는 거는 격리시킨 DB에서 진행하자. (배치용 DB 같은)
		- `메모리 누수` - 애플리케이션 엔지니어가 매일 수행해야 함
		- `비정상 동작 시 자율제어` - `자동 DoS 판정`, `자동 재시작`, `자동 쿼리제거`가 있음

##### 비정상 동작 시 자율제어
자동 DoS 판정 : F5(새로 고침) 어택, 조회수?와 비슷한 항목을 늘리기 위해 새로 고침을 계속 하는 행위
- 1시간에 특정 IP 주소로부터 다수의 요청이 올 경우 당분간 403 반환 (rate limiter 구현)

자동 재시작(AP, 호스트 OS) : 어느 정도 리소스를 지나치게 사용했다라고 판단되면 웹 서버를 재시작해야 함
- 가상화되어 있다면 OS별로 재시작해야 함

자동 쿼리제거(소요 시간이 긴 SQL KILL) : DB에서 어떤 쿼리가 실행되고 있는지 10초에 한 번씩 파악
- 쿼리를 파악하고, 어느 정도 이상으로 시간이 경과된 쿼리를 강제적으로 KILL

> 안정화 대책 요약
> - 적절한 여유(버퍼) 유지
> 	- 메모리량, CPU 부하 -> 한계의 7할까지만 운영
> - 불안정 요인 제거
> 	- SQL 부하의 상한성을 미리 정함
> 		-> 부하가 높은 SQL을 필요로 하는 경우 별도 호스트(별도 DB)로
> 			- 메모리 누수 줄이기
> 			- 이상 동작 시 자율제어
> 	- 자동 DoS 판정(mod_dosdetector)
> 	- 자동 재시작(AP 서버, 호스트 OS)
> 	- 자동 쿼리제거(소요시간이 긴 SQL KILL)

